"""Module containing all the custom objects defined to help with parsing the metadata generated by the DASK-Mofka plugins.
"""
from datetime import datetime
from enum import Enum
from typing import Dict, List, Union

from dask_md_helpers import generate_times

class TaskState(Enum) :
    """Describes the possible states of a :class:`~dask_md_obj.Task`
    """
    # TODO : put into a logical order, perhaps can check if QUEUED > RELEASED later.
    RELEASED = 'released'
    WAITING = 'waiting'
    QUEUED = 'queued'
    PROCESSING = 'processing'
    MEMORY = 'memory'
    FORGOTTEN = 'forgotten'

class TransferTypeEnum(Enum) :
    """Describes whether a :class:`~dask_md_obj.WXferEvent` represents an incoming or outgoing file transfer.
    """
    INCOMING = 'incoming_transfer'
    OUTGOING = 'outgoing_transfer'

class EventSource :
    """Class that describes the source of an Event message.

    Class that describes the source of an Event message. Primarily, it 
    describes the IP Address of the source of the message, as well as
    the stimulus ID of the event that caused the message to be sent.

    TODO: Describe what stimulus ID is.
    """
    #: IP Address of the message source.
    addr = None
    #: Stimulus ID that caused the message to be sent.
    stim_id = None
    # TODO : examples or enums for stimulus types

    def __init__(self, addr, stim_id) :
        self.addr = addr
        self.stim_id = stim_id

    def __str__(self) -> str :
        return "Called from: {e.addr}\nStimulus ID: {e.stim_id}".format(e=self)

class Event:
    # TODO: make useful
    pass

class SchedulerEvent(Event) :
    """An Event that was sent by a Scheduler instance.

    Object representing an event that was sent by a DASK Scheduler instance.
    Contains information unique to messages sent by a DASK scheduler.
    """
    t_event : datetime
    """ The `datetime` of the event message itself.
    """
    #: The `datetime` of the task start, if applicable.
    t_begins : Union[datetime, None]
    #: The `datetime` of the task end, if applicable.
    t_ends : Union[datetime, None]

    #: The starting state of the task described in this message, as a :class:`~dask_md_objs.TaskState`.
    start: TaskState
    #: The ending state of the task described in this message, as a :class:`~dask_md_objs.TaskState`.
    finish: TaskState

    #: The :class:`~dask_md_objs.EventSource` describing the source of the message that led to the creation of this SchedulerEvent.
    source: EventSource
    
    #: The id of the task that this SchedulerEvent is describing, as a string.
    task_id: str
    # TODO : key, thread, worker, prefix, group
    def __init__(self, data) :
        """Initialize a new SchedulerEvent object.

        :param data: The pandas dataframe row that represents all data associated with a SchedulerEvent, including 'time', 'begins', 'ends', 'called_from', 'stimulus_id', and 'key'.
        :type data: pandas dataframe row
        """
        self.t_event, self.t_begins, self.t_ends = generate_times(
            {key: data[key]
             for key in ["time","begins","ends"]}
        )

        self.start = TaskState(data["start"] )
        self.finish = TaskState(data["finish"])

        self.source = EventSource(data["called_from"], data["stimulus_id"])

        self.task_id = data["key"]

    def __str__(self) -> str :
        return "Scheduler Event for task {e.task_id}\n".format(e=self) + \
              "\tEvent time: {e.t_event}\tBegin time: {e.t_begins}\tEnd time: {e.t_ends}\n".format(e=self) + \
              "\tStart: {e.start.value}\t\t\t\tFinish: {e.finish.value}\n".format(e=self) + \
              "\tSource: \n\t\t{source_info}\n".format(source_info = "\n\t\t".join(self.source.__str__().split("\n")))
              
class WXferEvent(Event) :
    """An Event that represents a file transfer between Workers.

    An object that represents an event message that signifies a file has
    been transferred between two workers.
    """
    start: datetime
    stop: datetime
    middle: datetime
    duration: float

    keys: Dict[str,int]
    """Dictionary containing the `keys` information from the worker transfer message file.
    
    This dictionary is generating by `eval` ing the data directly."""

    total: int
    bandwidth: float
    compressed: float

    #: IP address representing the `who` column of the worker transfer event - the other worker involved in this event.
    requestor: str # ip addr; who
    #: IP address representing the `called_from` column of the worker transfer event - the worker that noted this event.
    fulfiller: str # called_from

    #: The type of transfer this event describes, using a :class:`~dask_md_objs.TransferTypeEnum`. Can be either INCOMING or OUTGOING.
    transfer_type: TransferTypeEnum

    #: The time this event was noted.
    time : datetime

    def __init__(self, data) :
        #: This is an example docstring.
        self.start = datetime.fromtimestamp(data['start'])
        self.stop = datetime.fromtimestamp(data['stop'])
        self.middle = datetime.fromtimestamp(data['middle'])
        self.duration = data['duration']

        self.keys = eval(data['keys'])

        self.total = data['total']
        self.bandwidth = data['bandwidth']
        self.compressed = data['compressed']

        self.requestor = data['who']
        self.fulfiller = data['called_from']

        self.transfer_type = TransferTypeEnum(data['type'])

        self.time = datetime.fromtimestamp(data['time'])
    
    def __str__(self) -> str :
        out = "Worker Transfer Event (Type: {t})\n".format(t=self.transfer_type)
        out += "\tEvent time: {t}\n".format(t=self.time)
        out += "\tRequestor (Them): {r}\tFulfiller (Me): {f}\n".format(r=self.requestor, f=self.fulfiller)
        out += "\tStart: {s}\tMiddle: {m}\tEnd: {e}\t(Duration: {d})\n".format(
            s=self.start, m=self.middle, e=self.stop, d=self.duration
        )
        out += "\tTotal Transfer: {t}\n".format(t=self.total)
        out += "\tAffiliated Keys:"
        
        for key in self.keys :
            out += "\n\t\t{k}".format(k=key)

        out += "\n"
        return out
    
    def is_only_1_task(self) -> bool :
        """Returns whether this worker transfer event only relates to one task.

        :return: True if this wxferevent only relates to one task.
        :rtype: bool
        """
        if len(list(self.keys.keys())) == 1 :
            return True
        else :
            False

    def n_tasks(self) -> int :
        """Returns the number of tasks this wxfer event is related to.

        :return: An integer representing the number of tasks this wxfer event is related to.
        :rtype: int
        """
        return len(list(self.keys.keys()))

    def get_key_name(self, i: int = 0) -> str :
        """Given an integer index, returns the name of the task at that position in its internal list of keys.

        :param i: The integer index of the desired task id, defaults to 0
        :type i: int, optional
        :return: The name of the task found
        :rtype: str
        """
        return list(self.keys.keys())[i]
    
    def __eq__(self, other) -> bool :
        if not isinstance(other, WXferEvent) :
            raise NotImplementedError("Cannot check if WXferEvent is equal to {}".format(type(other)))
        else :
            if not (self.start == other.start) or \
                not (self.stop == other.stop) or \
                not (self.middle == other.middle) or \
                not (self.duration == other.duration) or \
                not (self.keys == other.keys) or \
                not (self.total == other.total) or \
                not (self.bandwidth == other.bandwidth) or \
                not (self.compressed == other.compressed) or \
                not (self.requestor == other.requestor) or \
                not (self.fulfiller == other.fulfiller) or \
                not (self.transfer_type == other.transfer_type) or \
                not (self.time == other.time) :
                return False
        return True
    
class Task:
    name: str
    events: List[Event]

    t_start: datetime = None
    t_end: datetime = None

    workers: List[str]
    initiated: bool = False
    def __init__(self, first_event: Union[Event, None]) :
        self.events = []
        self.workers = []

        if first_event is not None :
            if isinstance(first_event, SchedulerEvent) :
                self.name = first_event.task_id
                self.initiated = True
                
                self.add_scheduler_event(first_event)
            elif isinstance(first_event, WXferEvent) :
                self.name = first_event.get_key_name()

                self.add_wxfer_event(first_event)
            else :
                raise ValueError("Unexpected Event Type in Task Construction.")

    def add_event(self, event_inp: Event) -> None:
        if isinstance(event_inp, SchedulerEvent) :
            self.add_scheduler_event(event_inp)
        elif isinstance(event_inp, WXferEvent) :
            if event_inp not in self.events :
                self.add_wxfer_event(event_inp)
        else :
            raise ValueError("Unexpected Event Type in Task.add_event()") 

    def add_wxfer_event(self, event_inp: WXferEvent) -> None :
        self.events.append(event_inp)

    def add_scheduler_event(self, event_inp: SchedulerEvent) -> None :
        self.events.append(event_inp)

        if event_inp.t_begins is not None :
            if self.t_start is None:
                self.t_start = event_inp.t_begins
            else :
                if event_inp.t_begins < self.t_start :
                    self.t_start = event_inp.t_begins

        if event_inp.t_ends is not None :
            if self.t_end is None:
                self.t_end = event_inp.t_ends
            else :
                if event_inp.t_ends < self.t_end :
                    self.t_end = event_inp.t_ends
    
    def return_wxfer_events(self, filter_type: TransferTypeEnum = None) -> List[WXferEvent] :
        """Returns a list of worker transfer events associated with the Task.

        :param filter_type: Whether to filter to only TransferTypeEnum.INCOMING or TransferTypeEnum.OUTGOING, defaults to None
        :type filter_type: :class:`TransferTypeEnum`, optional
        :return: A List of :class:`WXferEvent` s of the given `filter_type`, if any.
        :rtype: List[WXferEvent]
        """
        filter = filter_type is not None
        output = []
        for e in self.events :
            if isinstance(e, WXferEvent) :
                if filter :
                    if e.transfer_type == filter_type :
                        output.append(e)
                else :
                    output.append(e)
        return output

    def __str__(self) -> str :
        event_strs = ""
        for e in self.events :
            event_strs += e.__str__()

        out = "Task object for task {e.name}:\n".format(e=self)
        out += "\tEvent objects:\n\t\t{event_info}".format(event_info = "\n\t\t".join(event_strs.split("\n")))
        out = out.strip()
        out += "\n\tStart time: {e.t_start}\tEnd time: {e.t_end}\n".format(e=self)

        return out

class TaskHandler :
    tasks: Dict[str, Task]

    def __init__(self) :
        self.tasks = {}
    
    def add_event(self, event: Event) -> None :
        if type(event) is SchedulerEvent :
            self._inner_add_event(event.task_id, event)
        elif type(event) is WXferEvent :
            if event.is_only_1_task() :
                e_id: str = event.get_key_name(0)
                self._inner_add_event(e_id, event)
            else :
                for i in range(0, event.n_tasks()) :
                    i_id: str = event.get_key_name(i)
                    self._inner_add_event(i_id, event)

    def _inner_add_event(self, id:str, event:Event) :
        if id not in self.tasks.keys() :
            temp_task = Task(event)
            self.tasks[id] = temp_task
        else :
            self.tasks[id].add_event(event)
    
    def return_names(self) -> List[str] :
        return list(self.tasks.keys())
    
    def return_all_wxfer_events(self, filter_type: TransferTypeEnum = None) -> List[WXferEvent]:
        output: List[WXferEvent] = []
        for t in self.tasks.values() :
            output.extend(t.return_wxfer_events(filter_type))

        return list(set(output))
    
    def get_task_by_name(self, taskname:str) -> Task :
        return self.tasks[taskname]
