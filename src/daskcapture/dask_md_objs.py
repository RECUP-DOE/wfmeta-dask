"""Module containing all the custom objects defined to help with parsing the metadata generated by the DASK-Mofka plugins.
"""
from datetime import datetime
from enum import Enum
from typing import Dict, List, Union

from daskcapture.dask_md_helpers import generate_times

class TaskState(Enum) :
    """Describes the possible states of a :class:`~dask_md_obj.Task`
    """
    # TODO : put into a logical order, perhaps can check if QUEUED > RELEASED later.
    RELEASED = 'released'
    WAITING = 'waiting'
    QUEUED = 'queued'
    PROCESSING = 'processing'
    MEMORY = 'memory'
    FORGOTTEN = 'forgotten'

    # Worker-Specific States
    READY = 'ready'
    EXECUTING = 'executing'
    FETCH = 'fetch'
    FLIGHT = 'flight'
    CANCELLED = 'cancelled' # TODO: look into this one

class TransferTypeEnum(Enum) :
    """Describes whether a :class:`~dask_md_obj.WXferEvent` represents an incoming or outgoing file transfer.
    """
    INCOMING = 'incoming_transfer'
    OUTGOING = 'outgoing_transfer'

class EventSource :
    """Class that describes the source of an Event message.

    Class that describes the source of an Event message. Primarily, it 
    describes the IP Address of the source of the message, as well as
    the stimulus ID of the event that caused the message to be sent.

    TODO: Describe what stimulus ID is.
    """
    #: IP Address of the message source.
    addr = None
    #: Stimulus ID that caused the message to be sent.
    stim_id = None
    # TODO : examples or enums for stimulus types

    def __init__(self, addr, stim_id) :
        self.addr = addr
        self.stim_id = stim_id

    def __str__(self) -> str :
        return "Called from: {e.addr}\nStimulus ID: {e.stim_id}".format(e=self)

class Event:
    # TODO: make useful
    pass

class SchedulerEvent(Event) :
    """An Event that was sent by a Scheduler instance.

    Object representing an event that was sent by a DASK Scheduler instance.
    Contains information unique to messages sent by a DASK scheduler.
    """
    t_event : datetime
    """ The `datetime` of the event message itself.
    """
    #: The `datetime` of the task start, if applicable.
    t_begins : Union[datetime, None]
    #: The `datetime` of the task end, if applicable.
    t_ends : Union[datetime, None]

    #: The starting state of the task described in this message, as a :class:`~dask_md_objs.TaskState`.
    start: TaskState
    #: The ending state of the task described in this message, as a :class:`~dask_md_objs.TaskState`.
    finish: TaskState

    #: The :class:`~dask_md_objs.EventSource` describing the source of the message that led to the creation of this SchedulerEvent.
    source: EventSource
    
    #: The id of the task that this SchedulerEvent is describing, as a string.
    task_id: str
    # TODO : key, thread, worker, prefix, group
    def __init__(self, data) :
        """Initialize a new SchedulerEvent object.

        :param data: The pandas dataframe row that represents all data associated with a SchedulerEvent, including 'time', 'begins', 'ends', 'called_from', 'stimulus_id', and 'key'.
        :type data: pandas dataframe row
        """
        self.t_event, self.t_begins, self.t_ends = generate_times(
            {key: data[key]
             for key in ["time","begins","ends"]}
        )

        self.start = TaskState(data["start"] )
        self.finish = TaskState(data["finish"])

        self.source = EventSource(data["called_from"], data["stimulus_id"])

        self.task_id = data["key"]

    def __str__(self) -> str :
        return "Scheduler Event for task {e.task_id}\n".format(e=self) + \
              "\tEvent time: {e.t_event}\tBegin time: {e.t_begins}\tEnd time: {e.t_ends}\n".format(e=self) + \
              "\tStart: {e.start.value}\t\t\t\tFinish: {e.finish.value}\n".format(e=self) + \
              "\tSource: \n\t\t{source_info}\n".format(source_info = "\n\t\t".join(self.source.__str__().split("\n")))
              
class WorkerEvent(Event) :
    """Event that represents a change in Worker task state.

    """
    start: TaskState
    finish: TaskState
    worker_id: str # TODO: change into an ip addr class
    t_event: datetime # TODO: normalize names for datetime attributes

    key: str # TODO: normalize type for keys

    def __init__(self, data) :
        self.start = TaskState(data["start"])
        self.finish = TaskState(data["finish"])

        self.worker_id = data["called_from"]
        self.t_event = datetime.fromtimestamp(data["time"])
        self.key = data["key"]

    def __str__(self) -> str :
        return "Worker Event for task {e.key}\n".format(e=self) + \
        "\tEvent time: {e.t_event}\n".format(e=self) + \
        "\tStart: {e.start.value}\t\t\t\tFinish: {e.finish.value}\n".format(e=self) + \
        "\tSource: {e.worker_id}\n".format(e=self)


class WXferEvent(Event) :
    """An Event that represents a file transfer between Workers.

    An object that represents an event message that signifies a file has
    been transferred between two workers.
    """
    start: datetime
    stop: datetime
    middle: datetime
    duration: float

    keys: Dict[str,int]
    """Dictionary containing the `keys` information from the worker transfer message file.
    
    This dictionary is generating by `eval` ing the data directly."""

    total: int
    bandwidth: float
    #: nan for any Incoming transfer events.
    compressed: float

    #: IP address representing the `who` column of the worker transfer event - the other worker involved in this event.
    requestor: str # ip addr; who
    #: IP address representing the `called_from` column of the worker transfer event - the worker that noted this event.
    fulfiller: str # called_from

    #: The type of transfer this event describes, using a :class:`~dask_md_objs.TransferTypeEnum`. Can be either INCOMING or OUTGOING.
    transfer_type: TransferTypeEnum

    #: The time this event was noted.
    t_event : datetime

    def __init__(self, data) :
        #: This is an example docstring.
        self.start = datetime.fromtimestamp(data['start'])
        self.stop = datetime.fromtimestamp(data['stop'])
        self.middle = datetime.fromtimestamp(data['middle'])
        self.duration = data['duration']

        self.keys = eval(data['keys'])

        self.total = data['total']
        self.bandwidth = data['bandwidth']
        self.compressed = data['compressed']

        self.requestor = data['who']
        self.fulfiller = data['called_from']

        self.transfer_type = TransferTypeEnum(data['type'])

        self.t_event = datetime.fromtimestamp(data['time'])
    
    def __str__(self) -> str :
        out = "Worker Transfer Event (Type: {t})\n".format(t=self.transfer_type)
        out += "\tEvent time: {t}\n".format(t=self.t_event)
        out += "\tRequestor (Them): {r}\tFulfiller (Me): {f}\n".format(r=self.requestor, f=self.fulfiller)
        out += "\tStart: {s}\tMiddle: {m}\tEnd: {e}\t(Duration: {d})\n".format(
            s=self.start, m=self.middle, e=self.stop, d=self.duration
        )
        out += "\tTotal Transfer: {t}\n".format(t=self.total)
        out += "\tAffiliated Keys:"
        
        for key in self.keys :
            out += "\n\t\t{k}".format(k=key)

        out += "\n"
        return out
    
    def is_only_1_task(self) -> bool :
        """Returns whether this worker transfer event only relates to one task.

        :return: True if this wxferevent only relates to one task.
        :rtype: bool
        """
        return len(self.keys.keys()) == 1

    def n_tasks(self) -> int :
        """Returns the number of tasks this wxfer event is related to.

        :return: An integer representing the number of tasks this wxfer event is related to.
        :rtype: int
        """
        return len(list(self.keys.keys()))

    def get_key_name(self, i: int = 0) -> str :
        """Given an integer index, returns the name of the task at that position in its internal list of keys.

        :param i: The integer index of the desired task id, defaults to 0
        :type i: int, optional
        :return: The name of the task found
        :rtype: str
        """
        return list(self.keys.keys())[i]
    
    def return_key_names(self) -> List[str]:
        """Return all of the key names related to this wxfer event.

        :return: List of key names
        :rtype: List[str]
        """
        return list(self.keys.keys())
    
    def _check_most_equiv(self, other: 'WXferEvent') -> bool :
        """Checks most equivalencies between WXfer events to avoid repetition in identical_except_(fulfiller,requestor) and __eq__. 

        Checks the equivalency of all internal attributes of Wxfer events except for requestor and fulfillor. 
        In the case where the WXfer events are `TransferType.INCOMING`, `compressed` is ignored because `compressed` is not provided for incoming messages.

        :param other: Other WXfer event to compare against.
        :type other: WXferEvent
        :return: True if all attributes except requestor or fulfiller match.
        :rtype: bool
        """
        if not (self.start == other.start) or \
            not (self.stop == other.stop) or \
            not (self.middle == other.middle) or \
            not (self.duration == other.duration) or \
            not (self.keys == other.keys) or \
            not (self.total == other.total) or \
            not (self.bandwidth == other.bandwidth) or \
            not (self.transfer_type == other.transfer_type) or \
            not (self.t_event == other.t_event) :
                return False

        elif self.transfer_type == TransferTypeEnum.OUTGOING and \
            not (self.compressed == other.compressed) :
                return False

        return True

    
    def identical_except_fulfiller(self, other: 'WXferEvent') -> bool :
        """Returns true if the given WXferEvent is identical except for the fulfiller field.

        Every attribute betwee this and the other wxfer event must match identically, and the fulfiller attributes _must_ differ.

        :param other: The WXferEvent to compare to
        :type other: WXferEvent
        :return: True if the events are identical except fulfiller
        :rtype: bool
        """
        if self._check_most_equiv(other) :
            if (self.fulfiller != other.fulfiller) and (self.requestor == other.requestor) :
                return True
            
        return False
    
    def identical_except_requestor(self, other: 'WXferEvent') -> bool :
        """Returns true if the given WXferEvent is identical except for the requestor field.

        Every attribute betwee this and the other wxfer event must match identically, and the requestor attributes _must_ differ.

        :param other: The WXferEvent to compare to
        :type other: WXferEvent
        :return: True if the events are identical except requestor
        :rtype: bool
        """
        if self._check_most_equiv(other) :
            if (self.fulfiller == other.fulfiller) and (self.requestor != other.requestor) :
                return True
            
        return False

    def __eq__(self, other) -> bool :
        if not isinstance(other, WXferEvent) :
            if isinstance(other, SchedulerEvent) :
                return False
            raise NotImplementedError("Cannot check if WXferEvent is equal to {}".format(type(other)))
        else :
            if self._check_most_equiv(other) :
                if (self.fulfiller == other.fulfiller) and (self.requestor == other.requestor) :
                    return True
            
            return False
    
class Task:
    name: str
    events: List[Event]

    t_start: datetime = None
    t_end: datetime = None

    workers: List[str]
    initiated: bool = False

    def __init__(self, first_event: Union[Event, None]) :
        self.events = []
        self.workers = []

        if first_event is not None :
            if isinstance(first_event, SchedulerEvent) :
                self.name = first_event.task_id
                self.initiated = True
                
                self.add_scheduler_event(first_event)
            elif isinstance(first_event, WXferEvent) :
                self.name = first_event.get_key_name()
                self.initiated = True

                self.add_wxfer_event(first_event)
            elif isinstance(first_event, WorkerEvent) :
                self.name = first_event.key
                self.initiated = True

                self.add_worker_event(first_event)
            else :
                raise ValueError("Unexpected Event Type in Task Construction.")

    def add_event(self, event_inp: Event) -> None:
        if isinstance(event_inp, SchedulerEvent) :
            self.add_scheduler_event(event_inp)
        elif isinstance(event_inp, WXferEvent) :
            if event_inp not in self.events :
                self.add_wxfer_event(event_inp)
        elif isinstance(event_inp, WorkerEvent) :
            self.add_worker_event(event_inp)
        else :
            raise ValueError("Unexpected Event Type in Task.add_event()") 

    def add_wxfer_event(self, event_inp: WXferEvent) -> None :
        worker_req = event_inp.requestor
        worker_ful = event_inp.fulfiller

        if worker_req not in self.workers :
            self.workers.append(worker_req)
        if worker_ful not in self.workers :
            self.workers.append(worker_ful)

        self.events.append(event_inp)

    def add_worker_event(self, event_inp: WorkerEvent) -> None :
        worker_inp = event_inp.worker_id
        if worker_inp not in self.workers :
            self.workers.append(worker_inp)

        self.events.append(event_inp)

    def add_scheduler_event(self, event_inp: SchedulerEvent) -> None :
        self.events.append(event_inp)

        if event_inp.t_begins is not None :
            if self.t_start is None:
                self.t_start = event_inp.t_begins
            else :
                if event_inp.t_begins < self.t_start :
                    self.t_start = event_inp.t_begins

        if event_inp.t_ends is not None :
            if self.t_end is None:
                self.t_end = event_inp.t_ends
            else :
                if event_inp.t_ends < self.t_end :
                    self.t_end = event_inp.t_ends

    def sort_events_by_time(self) -> None :
        """Sorts `events` to be in time order.

        Compares events using their `time` attributes to list events in the order the message was sent to MOFKA.
        """
        self.events.sort(key=lambda x: x.t_event)

    
    def return_wxfer_events(self, filter_type: TransferTypeEnum = None) -> List[WXferEvent] :
        """Returns a list of worker transfer events associated with the Task.

        :param filter_type: Whether to filter to only TransferTypeEnum.INCOMING or TransferTypeEnum.OUTGOING, defaults to None
        :type filter_type: :class:`TransferTypeEnum`, optional
        :return: A List of :class:`WXferEvent` s of the given `filter_type`, if any.
        :rtype: List[WXferEvent]
        """
        filter = (filter_type is not None)
        output = []
        for e in self.events :
            if isinstance(e, WXferEvent) :
                if filter :
                    if e.transfer_type == filter_type :
                        output.append(e)
                else :
                    output.append(e)
        return output

    def __str__(self) -> str :
        event_strs = ""
        for e in self.events :
            event_strs += e.__str__()

        out = "Task object for task {e.name}:\n".format(e=self)
        out += "\tEvent objects:\n\t\t{event_info}".format(event_info = "\n\t\t".join(event_strs.split("\n")))
        out = out.strip()
        out += "\n\tStart time: {e.t_start}\tEnd time: {e.t_end}\n".format(e=self)

        return out

class TaskHandler :
    tasks: Dict[str, Task]

    def __init__(self) :
        self.tasks = {}
    
    def add_event(self, event: Event) -> None :
        if type(event) is SchedulerEvent :
            self._inner_add_event(event.task_id, event)
        elif type(event) is WXferEvent :
            if event.is_only_1_task() :
                e_id: str = event.get_key_name(0)
                self._inner_add_event(e_id, event)
            else :
                for i in range(0, event.n_tasks()) :
                    i_id: str = event.get_key_name(i)
                    self._inner_add_event(i_id, event)
        elif type(event) is WorkerEvent :
            self._inner_add_event(event.key, event)
        else :
            raise NotImplementedError("Unknown type handed to TaskHandler.")

    def _inner_add_event(self, id:str, event:Event) :
        if id not in self.tasks.keys() :
            temp_task = Task(event)
            self.tasks[id] = temp_task
        else :
            self.tasks[id].add_event(event)
    
    def return_names(self) -> List[str] :
        return list(self.tasks.keys())
    
    def return_all_wxfer_events(self, filter_type: TransferTypeEnum = None) -> List[WXferEvent]:
        output: List[WXferEvent] = []
        for t in self.tasks.values() :
            returned = t.return_wxfer_events(filter_type)
            for r in returned :
                if r not in output :
                    output.append(r)

        return output

    def return_all_events(self) -> List[Event] :
        output: List[Event] = []
        for t in self.tasks.values() :
            raise NotImplementedError()
        
        return list(set(output))
    
    def get_task_by_name(self, taskname:str) -> Task :
        return self.tasks[taskname]
    
    def _get_arbitrary_task(self) -> Task :
        """Returns an arbitrary task for debug purposes.

        The returned task is NOT random: the the `keys()` attribute of 
        TaskHandler's `task` attribute is turned into a list, and the 
        first entry from this list is used to return a Task.

        :return: An arbitrary Task in the TaskHandler's tasks attribute
        :rtype: Task
        """
        return self.tasks[list(self.tasks.keys())[0]]
    
    def sort_tasks_by_time(self) -> None :
        """Instructs all stored tasks to sort their events by time.
        """
        for k,v in self.tasks.items() :
            v.sort_events_by_time()
    